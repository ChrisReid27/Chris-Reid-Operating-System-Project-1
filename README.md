# Computer-Operating-Systems-Project-1
Files found in master branch


# Report for my Shell Desgin

My shell is designed with the specified tasks in mind like signal handling, process management, termination handling, and I/O manipulation. Within the shell's main function, the logic is based on Read-Evaluate-Print loop or REPL method. Input is read using fgets() after displaying a dynamic prompt showing the current working directory using getcwd(). For tokenization and subsittution, the function handles parsing the input string into an array of arguments and performs environment variable substitution before execution of commands. For classification of commands there's piping, buil-in's, and external execution that my shell checks for in sequence. If a pipe is detected, the command is handled by dedicated multi-process logic. Next, if it's not a pipe, it checks for internal commands. And then if it's neither, a new process is forked to execute an external program. External commands are executed using fork() and execvp(). The parent process uses waitpid() to manage child execution, either in the foreground or the background. For error handling, built-in errors use perror() or they use fprintf(stderr, ...etc.) message. External command failures like command not found will lead to the child process calling perror("execvp failed") and exiting with a non-zero status, so the shell doesn't crash.

Design of the shell included the key system and feature calls for the different tasks. Task 1's Built-In commands and environment used commands pwd, cd, env, setenv and $, with functions used being getcwd(), chdir()/getenv(), environ (*as a global variable), setenv(), and getenv() repectively. Pwd prints the full path of the current directory, cd changes the working directory. If no argument is provided, it defaults to the value of $HOME, env iterates through the null-terminated global array extern char **environ to print all environment variables, setenv parses the VAR=value format and uses setenv(VAR, value, 1) to set or overwrite the variable, and $ is handled during tokenization where any token starting with $ is replaced by its value from the environment. Task 2 and 3 focused on Process Control and Execution where the execution of non-built-in commands relies on the core UNIX process model. System calls included fork() (creates a copy of the shell process), execvp() (replaces child process image with a new program), and waitpid() (parent pauses its execution until the child in the foreground finishes). The fork() call distinguishes between parent (pid > 0) and child (pid == 0) to determine execution path. The execvp() call gets called in the child process where if it returns, execution is failed, and the child must exit(1). The waitpid() call is used with the 0 option to block until completion and is not called for background processes.

Task 4 and Task 5 were about Signal Handling, where management of signals ensures the process stability and robustness of the shell against external interruptions. Signal Handler calls include SIGINT and SIGALRM. There also was also the actual 10s timer, alarm(10). For SIGINT, the handler (sigint_handler) is registered in main() to print a newline and refresh the prompt, so ctrl-c doesn't terminate the shell. SIGALRM is used to terminate long running processes in the foreground. The handler (sigalrm_handler) checks the global fg_pid and uses kill(fg_pid, SIGKILL) to forcefully terminate processes that run beyond 10 seconds. The 10 second timer is started using alarm(10) and is called in the parent before waitpid(). Additionally, alarm(0) is used to cancel the timer if the child finishes early and waitpid() must loop if interrupted (errno == EINTR). Task 6 is the shell's I/O Redirection and Piping functionality where I/O manipulation requires the file descriptors of the child processes to be modified. For I/O (<,>), the child opens the target file (open()). dup2() is used to replace the standard input/output file descriptor (STDIN_FILENO or STDOUT_FILENO) with the file's descriptor. The original file descriptor is then closed. For piping (|), system calls used include pipe(), fork(), dup2(), and waitpid(). During setup for piping, the parent creates the pipe channel (fd[0] read, fd[1] write) and forks two children (pid1 and pid2). Write command child closes unused read end and redirects stdout (STDOUT\_FILENO) to the pipe's write end and xecutes cmd1. Read command child does vice versa: closes unused write end and redirects stdin (STDIN\_FILENO) to the pipe's read end and executes cmd2. Synchronization is done back within the parent where both pipe ends get closed and waits for both children to complete before continuing.
