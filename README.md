# Computer-Operating-Systems-Project-1
Files found in master branch


# Report for my Shell Desgin

    My shell is designed with the specified tasks in mind like signal handling, process management, termination handling, and I/O manipulation. Within the shell's main function, the logic is based on Read-Evaluate-Print loop or REPL method. Input is read using fgets() after displaying a dynamic prompt showing the current working directory using getcwd(). For tokenization and subsittution, the function handles parsing the input string into an array of arguments and performs environment variable substitution before execution of commands. For classification of commands there's piping, buil-in's, and external execution that my shell checks for in sequence. If a pipe is detected, the command is handled by dedicated multi-process logic. Next, if it's not a pipe, it checks for internal commands. And then if it's neither, a new process is forked to execute an external program. External commands are executed using fork() and execvp(). The parent process uses waitpid() to manage child execution, either in the foreground or the background. For error handling, built-in errors use perror() or they use fprintf(stderr, ...etc.) message. External command failures like command not found will lead to the child process calling perror("execvp failed") and exiting with a non-zero status, so the shell doesn't crash.

    Design of the shell included the key system and feature calls for the different tasks. Task 1's Built-In commands and environment used commands pwd, cd, env, setenv and $, with functions used being getcwd(), chdir()/getenv(), environ (*as a global variable), setenv(), and getenv() repectively. Pwd prints the full path of the current directory, cd changes the working directory. If no argument is provided, it defaults to the value of $HOME, env iterates through the null-terminated global array extern char **environ to print all environment variables, setenv parses the VAR=value format and uses setenv(VAR, value, 1) to set or overwrite the variable, and $ is handled during tokenization where any token starting with $ is replaced by its value from the environment. Task 2 and 3 focused on Process Control and Execution where the execution of non-built-in commands relies on the core UNIX process model. System calls included fork() (creates a copy of the shell process), execvp() (replaces child process image with a new program), and waitpid() (parent pauses its execution until the child in the foreground finishes). The fork() call distinguishes between parent (pid > 0) and child (pid == 0) to determine execution path. The execvp() call gets called in the child process where if it returns, execution is failed, and the child must exit(1). The waitpid() call is used with the 0 option to block until completion and is not called for background processes.
