# Computer-Operating-Systems-Project-1
Source code and assignement files found in master branch.


# Shell Design Report

My shell is designed with the specified tasks in mind like signal handling, process management, termination handling, and I/O manipulation. Within the shell's main function, the logic is based on Read-Evaluate-Print loop or REPL method. Input is read using fgets() after displaying a dynamic prompt showing the current working directory using getcwd(). For tokenization and subsittution, the function handles parsing the input string into an array of arguments and performs environment variable substitution before execution of commands. For classification of commands there's piping, buil-in's, and external execution that my shell checks for in sequence. If a pipe is detected, the command is handled by dedicated multi-process logic. Next, if it's not a pipe, it checks for internal commands. And then if it's neither, a new process is forked to execute an external program. External commands are executed using fork() and execvp(). The parent process uses waitpid() to manage child execution, either in the foreground or the background. For error handling, built-in errors use perror() or they use fprintf(stderr, ...etc.) message. External command failures like command not found will lead to the child process calling perror("execvp failed") and exiting with a non-zero status, so the shell doesn't crash.

Design of the shell included the key system and feature calls for the different tasks. Task 1's Built-In commands and environment used commands pwd, cd, env, setenv and $, with functions used being getcwd(), chdir()/getenv(), environ (as a global variable), setenv(), and getenv() repectively. Pwd prints the full path of the current directory, cd changes the working directory. If no argument is provided, it defaults to the value of $HOME, env iterates through the null-terminated global array extern char **environ to print all environment variables, setenv parses the VAR=value format and uses setenv(VAR, value, 1) to set or overwrite the variable, and $ is handled during tokenization where any token starting with $ is replaced by its value from the environment. Task 2 and 3 focused on Process Control and Execution where the execution of non-built-in commands relies on the core UNIX process model. System calls included fork() (creates a copy of the shell process), execvp() (replaces child process image with a new program), and waitpid() (parent pauses its execution until the child in the foreground finishes). The fork() call distinguishes between parent (pid > 0) and child (pid == 0) to determine execution path. The execvp() call gets called in the child process where if it returns, execution is failed, and the child must exit(1). The waitpid() call is used with the 0 option to block until completion and is not called for background processes.

Task 4 and Task 5 were about Signal Handling, where management of signals ensures the process stability and robustness of the shell against external interruptions. Signal Handler calls include SIGINT and SIGALRM. There also was also the actual 10s timer, alarm(10). For SIGINT, the handler (sigint_handler) is registered in main() to print a newline and refresh the prompt, so ctrl-c doesn't terminate the shell. SIGALRM is used to terminate long running processes in the foreground. The handler (sigalrm_handler) checks the global fg_pid and uses kill(fg_pid, SIGKILL) to forcefully terminate processes that run beyond 10 seconds. The 10 second timer is started using alarm(10) and is called in the parent before waitpid(). Additionally, alarm(0) is used to cancel the timer if the child finishes early and waitpid() must loop if interrupted (errno == EINTR). Task 6 is the shell's I/O Redirection and Piping functionality where I/O manipulation requires the file descriptors of the child processes to be modified. For I/O (<,>), the child opens the target file (open()). dup2() is used to replace the standard input/output file descriptor (STDIN_FILENO or STDOUT_FILENO) with the file's descriptor. The original file descriptor is then closed. For piping (|), system calls used include pipe(), fork(), dup2(), and waitpid(). During setup for piping, the parent creates the pipe channel (fd[0] read, fd[1] write) and forks two children (pid1 and pid2). Write command child closes unused read end and redirects stdout (STDOUT\_FILENO) to the pipe's write end and xecutes cmd1. Read command child does vice versa: closes unused write end and redirects stdin (STDIN\_FILENO) to the pipe's read end and executes cmd2. Synchronization is done back within the parent where both pipe ends get closed and waits for both children to complete before continuing.

Finally, there is code organization and cleanliness. The global variable extern char **environ; is declared to provide access to the environment variable array required for the env built-in. Similarly, volatile pid_t fg_pid = -1; is also global variable and is used to track the PID of the current foreground process. The volatile keyword ensures the compiler doesn't optimize its access, as it is modified by the background sigalrm_handler. Function prototypes include void sigint_handler(int sig) which handles ctrl-c in the parent shell, void sigalrm_handler(int sig) which handles the 10s timer expiration, and int tokenize_and_substitute(...etc.) which encapsulates the tokenization logic, making the main loop cleaner and responsible for the $var replacement feature. Other organizational inclusions are NULL termination, resource cleanup, and child signal handling. For NULL termination, the arguments array is always explicitly null-terminated (arguments[arg_count] = NULL), which is a mandatory requirement for both execvp() and proper iteration in the echo and env built-in commands. Reseource cleanup gets done every time file descriptors get closed after dup2() gets called in the child processes and in the parent process. This is important for piping logic because it prevents resource leaks and process hanging (due to file descriptors remaining open). Lastly there is the signal handling of the child, where child processes reset signal handlers (signal(SIGINT, SIG_DFL)) to the default behavior. This is necessary because if a child inherits the parent's handler, ctrl-c could be ignored when it should terminate the foreground command.
